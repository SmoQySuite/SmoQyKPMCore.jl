var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Note that for many methods there are two verions, one that relies on taking an instance of the KPMExpansion type as an argument, and a lower level one that does not.","category":"page"},{"location":"api/","page":"API","title":"API","text":"KPMExpansion\nupdate_kpmexpansion!\nupdate_kpmexpansion_bounds!\nupdate_kpmexpansion_order!\nkpm_coefs\nkpm_coefs!\nkpm_mul\nkpm_mul!\nkpm_eval\nkpm_eval!\napply_jackson_kernel!\napply_jackson_kernel","category":"page"},{"location":"api/","page":"API","title":"API","text":"KPMExpansion\nKPMExpansion(::Function, ::Any, ::Int, ::Int)\nupdate_kpmexpansion!\nupdate_kpmexpansion_bounds!\nupdate_kpmexpansion_order!\nkpm_coefs\nkpm_coefs!\nkpm_mul\nkpm_mul!\nkpm_eval\nkpm_eval!\napply_jackson_kernel!\napply_jackson_kernel","category":"page"},{"location":"api/#SmoQyKPMCore.KPMExpansion","page":"API","title":"SmoQyKPMCore.KPMExpansion","text":"mutable struct KPMExpansion{T<:AbstractFloat, Tfft<:FFTW.r2rFFTWPlan}\n\nA type to represent the Chebyshev polynomial expansion used in the KPM algorithm.\n\nFields\n\nM::Int: Order of the Chebyshev polynomial expansion.\nbounds::NTuple{2,T}: Bounds on eigenspectrum in the KPM algorithm.\nbuf::Vector{T}: The first M elements of this vector of the Chebyshev expansion coefficients.\nr2rplan::Tfft: Plan for performing DCT to efficiently calculate the Chebyshev expansion coefficients via Chebyshev-Gauss quadrature.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyKPMCore.KPMExpansion-Tuple{Function, Any, Int64, Int64}","page":"API","title":"SmoQyKPMCore.KPMExpansion","text":"KPMExpansion(func::Function, bounds, M::Int, N::Int = 2*M)\n\nInitialize an instance of the KPMExpansion type to approximate the univariate function func, called as func(x), with a order M Chebyshev polynomial expansion on the interval bounds[1] < x bounds[2]. Here, N ≥ M is the number of points at which func is evaluated on that specified interval, which are then used to calculate the expansion coeffiencents via Chebyshev-Gauss quadrature.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyKPMCore.update_kpmexpansion!","page":"API","title":"SmoQyKPMCore.update_kpmexpansion!","text":"update_kpmexpansion!(\n    kpm_expansion::KPMExpansion{T}, func::Function, bounds, M::Int, N::Int = 2*M\n) where {T<:AbstractFloat}\n\nIn-place update an instance of KPMExpansion to reflect new values for eigenspectrum bounds, expansion order M, and number of points at which the expanded function is evaluated when computing the expansion coefficients. This includes recomputing the expansion coefficients.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyKPMCore.update_kpmexpansion_bounds!","page":"API","title":"SmoQyKPMCore.update_kpmexpansion_bounds!","text":"update_kpmexpansion_bounds!(\n    kpm_expansion::KPMExpansion{T}, func::Function, bounds\n) where {T<:AbstractFloat}\n\nIn-place update an instance of KPMExpansion to reflect new values for eigenspectrum bounds, recomputing the expansion coefficients.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyKPMCore.update_kpmexpansion_order!","page":"API","title":"SmoQyKPMCore.update_kpmexpansion_order!","text":"update_kpmexpansion_order!(\n    kpm_expansion::KPMExpansion, func::Function, M::Int, N::Int = 2*M\n)\n\nIn-place update the expansion order M for an instance of KPMExpansion, recomputing the expansion coefficients. It is also possible to udpate the number of point N the function func is evaluated at to calculate the expansion coefficients.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyKPMCore.kpm_coefs","page":"API","title":"SmoQyKPMCore.kpm_coefs","text":"kpm_coefs(func::Function, bounds, M::Int, N::Int = 2*M)\n\nCalculate and return the Chebyshev expansion coefficients. Refer to kpm_coefs! for more information.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyKPMCore.kpm_coefs!","page":"API","title":"SmoQyKPMCore.kpm_coefs!","text":"kpm_coefs!(\n    coefs::AbstractVector{T}, func::Function, bounds,\n    buf::Vector{T} = zeros(T, 2*length(coefs)),\n    r2rplan::FFTW.r2rFFTWPlan = FFTW.plan_r2r!(zeros(T, 2*length(coefs)), FFTW.REDFT10)\n) where {T<:AbstractFloat}\n\nCalculate and record the Chebyshev polynomial expansion coefficients to order M in the vector ceofs for the function func on the interval (bounds[1], bounds[2]). Let length(buf) be the number of evenly spaced points on the interval for which func is evaluated when performing Chebyshev-Gauss quadrature to compute the Chebyshev polynomial expansion coefficients.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyKPMCore.kpm_mul","page":"API","title":"SmoQyKPMCore.kpm_mul","text":"kpm_mul(\n    A, coefs::AbstractVector, bounds, v::T,\n    α₁::T = similar(v), α₂::T = similar(v), α₃::T = similar(v)\n) where {T<:AbstractVecOrMat}\n\nEvaluate and return the vector v^prime = F(A) cdot v where F(A) is represented by the Chebyshev expansion. For more information refer to kpm_mul!.\n\n\n\n\n\nkpm_mul(A, kpm_expansion::KPMExpansion, v::T) where {T<:AbstractVector}\n\nEvaluate and return the vector v^prime = F(A) cdot v where F(A) is represented by the Chebyshev expansion. For more information refer to kpm_mul!.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyKPMCore.kpm_mul!","page":"API","title":"SmoQyKPMCore.kpm_mul!","text":"kpm_mul!(\n    v′::T, A, coefs::AbstractVector, bounds, v::T,\n    α₁::T = similar(v), α₂::T = similar(v), α₃::T = similar(v)\n) where {T<:AbstractVecOrMat}\n\nEvaluates v^prime = F(A) cdot v, writing the result to v′, where F(A) is represented by the Chebyshev expansion. Here A is either a function that can be called as A(u,v) to evaluate u = Acdot v, modifying u in-place, or is a type for which the operation mul!(u, A, v) is defined. The vector coefs contains Chebyshev expansion coefficients to approximate F(A), where the eigenspectrum of A is contained in the interval (bounds[1], bounds[2]) specified by the bounds argument. The vector v is vector getting multiplied by the Chebyshev expansion for F(A). Lastly, the vectors (α₁, α₂, α₃) are passed to avoid dynamic memory allocations.\n\n\n\n\n\nkpm_mul!(\n    v′::T, A, kpm_expansion::KPMExpansion, v::T,\n    α₁::T = similar(v), α₂::T = similar(v), α₃::T = similar(v)\n) where {T<:AbstractVecOrMat}\n\nEvaluates v^prime = F(A) cdot v, writing the result to v′, where F(A) is represented by the Chebyshev expansion. Here A is either a function that can be called as A(u,v) to evaluate u = Acdot v, modifying u in-place, or is a type for which the operation mul!(u, A, v) is defined. Lastly, the vectors (α₁, α₂, α₃) are passed to avoid dynamic memory allocations.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyKPMCore.kpm_eval","page":"API","title":"SmoQyKPMCore.kpm_eval","text":"kpm_eval(x::AbstractFloat, coefs, bounds)\n\nEvaluate F(x) where x is real number in the interval bounds[1] < x < bound[2], and the function F(bullet) is represented by a Chebyshev expansion with coefficients given by the vector coefs.\n\n\n\n\n\nkpm_eval(A::AbstractMatrix, coefs, bounds)\n\nEvaluate and return the matrix F(A) where A is an operator with strictly real eigenvalues that fall in the interval (bounds[1], bounds[2]) specified by the bounds argument, and the function F(bullet) is represented by a Chebyshev expansion with coefficients given by the vector coefs.\n\n\n\n\n\nkpm_eval(x::T, kpm_expansion::KPMExpansion{T}) where {T<:AbstractFloat}\n\nEvaluate F(x) where x is real number in the interval bounds[1] < x < bound[2], and the function F(bullet) is represented by a Chebyshev expansion with coefficients given by the vector coefs.\n\n\n\n\n\nkpm_eval(A::AbstractMatrix{T}, kpm_expansion::KPMExpansion{T}) where {T<:AbstractFloat}\n\nEvaluate and return the matrix F(A) where A is an operator with strictly real eigenvalues and the function F(bullet) is represented by a Chebyshev expansion with coefficients given by the vector coefs.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyKPMCore.kpm_eval!","page":"API","title":"SmoQyKPMCore.kpm_eval!","text":"kpm_eval!(\n    F::T, A, coefs::AbstractVector, bounds,\n    T₁::T = similar(F), T₂::T = similar(F), T₃::T = similar(F)\n) where {T<:AbstractMatrix}\n\nEvaluate and write the matrix F(A) to F, where A is an operator with strictly real eigenvalues that fall in the interval (bounds[1], bounds[2]) specified by the bounds argument, and the function F(bullet) is represented by a Chebyshev expansion with coefficients given by the vector coefs. Lastly, the matrices (T₁, T₂, T₃) are used to avoid dynamic memory allocations.\n\n\n\n\n\nkpm_eval!(\n    F::T, A, kpm_expansion::KPMExpansion,\n    T₁::T = similar(F), T₂::T = similar(F), T₃::T = similar(F)\n) where {T<:AbstractMatrix}\n\nEvaluate and write the matrix F(A) to F, where A is an operator with strictly real eigenvalues and the function F(bullet) is represented by a Chebyshev expansion with coefficients given by the vector coefs. Lastly, the matrices (T₁, T₂, T₃) are used to avoid dynamic memory allocations.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyKPMCore.apply_jackson_kernel!","page":"API","title":"SmoQyKPMCore.apply_jackson_kernel!","text":"apply_jackson_kernel!(coefs)\n\nModify the Chebyshev expansion coefficients by applying the Jackson kernel to them.\n\n\n\n\n\napply_jackson_kernel!(kpm_expansion::KPMExpansion)\n\nModify the Chebyshev expansion coefficients by applying the Jackson kernel to them.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyKPMCore.apply_jackson_kernel","page":"API","title":"SmoQyKPMCore.apply_jackson_kernel","text":"apply_jackson_kernel(coefs)\n\nReturn the Chebyshev expansion coefficients transformed by the Jackson kernel.\n\n\n\n\n\n","category":"function"},{"location":"usage/","page":"Usage","title":"Usage","text":"EditURL = \"../../examples/usage.jl\"","category":"page"},{"location":"usage/#Usage","page":"Usage","title":"Usage","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"Here we demonstrate the basic usage for the SmoQyKPMCore package. Let us consider a 1D chain tight-binding model","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"hatH = -t sum_isigma (hatc_i+1sigma^dagger hatc_isigma + rm Hc)\n        = sum_sigma hatc_isigma^dagger H_ij hatc_jsigma","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"where hatc_isigma^dagger  (hatc_isigma) creates (annihilates) a spin-sigma electron on site i in the lattice, and t is the nearest-neighbor hopping amplitude. With H the Hamiltonian matrix, the corresponding density matrix is given by rho = f(H) where","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"f(epsilon) = frac11+e^beta (epsilon-mu) = frac12 left 1 + tanhleft(tfracbeta(epsilon-mu)2right) right","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"is the Fermi function, with beta = 1T is the inverse temperature and mu is the chemical potential. Here we will applying the kernel polynomial method (KPM) algorithm to approximate the density matrix rho by a Chebyshev polynomial expansion.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Let us begin by importing the packages we need.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"using LinearAlgebra\nusing SmoQyKPMCore","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Next, let us define the relevant system parameters.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"# Nearest-neighbor hopping amplitude.\nt = 1.0\n\n# Chemical potential.\nμ = 0.0\n\n# System size.\nL = 16\n\n# Inverse temperature.\nβ = 4.0;\nnothing #hide","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Now we need to construct the Hamiltonian matrix H.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"H = zeros(L,L)\nfor i in 1:L\n    j = mod1(i+1,L)\n    H[j,i], H[i,j] = -t, -t\nend\nH","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"We also need to define the Fermi function.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"# Fermi function.\nfermi(ϵ, μ, β) = (1+tanh(β*(ϵ-μ)/2))/2","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Let us calculate the exact density matrix rho so that we may asses the accuracy of the KPM method.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"# Diagonalize the Hamiltonian matrix.\nϵ, U = eigen(H)\n\n# Calculate the density matrix.\nρ = U * Diagonal(fermi.(ϵ, μ, β)) * adjoint(U)","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Now let use the KPM to approximate rho. We will need to define the order M of the expansion and give approximate bounds for the egenspectrum of H, making sure to overestimate the the true interval spanned by the egienvalues of H. Note that because we are considering the simple non-interacting model here, the exact eigenspectrum of H is known and spans the interval epsilon in -2t 2t","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"# Define eigenspectrum bounds.\nbounds = (-3.0t, 3.0t)\n\n# Define order of Chebyshev expansion used in KPM approximation.\nM = 10\n\n# Initialize expansion.\nkpm_expansion = KPMExpansion(x -> fermi(x, μ, β), bounds, M);\nnothing #hide","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Now let us test and see how good a job it does approximating the density matrix rho.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"# Initialize KPM density matrix approxiatmion\nρ_kpm = similar(H)\n\n# Initialize additional matrices to avoid dynamic memory allocation.\nT1, T2, T3 = similar(H), similar(H), similar(H)\n\n# Calculate KPM density matrix approximation.\nkpm_eval!(ρ_kpm, H, kpm_expansion, T1, T2, T3)\n\n# Check how good an approximation it is.\nprintln(\"Matrix Error = \", norm(ρ_kpm - ρ)/norm(ρ) )","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"It is also possible to efficiently multiply vectors by KPM approximation to the density matrix rho. Let us test this functionality on a random vector, seeing how accurate the result is.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"# Initialize random vector.\nv = randn(L)\n\n# Calculate exact product with density matrix.\nρv = ρ * v\n\n# Initialize vector to contain approximate product with densith matrix.\nρv_kpm = similar(v)\n\n# Initialize vectrs of avoid dynamic memory allocation.\nα1, α2, α3 = similar(v), similar(v), similar(v)\n\n# Calculate approximate product with density matrix.\nkpm_mul!(ρv_kpm, H, kpm_expansion, v, α1, α2, α3)\n\n# Check how good the approximation is.\nprintln(\"Vector Error = \", norm(ρv_kpm - ρv) / norm(ρv) )","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Let us now provide the KPM approximation with better bounds on the eigenspectrum and also increase the order the of the expansion and see how the result improves.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"# Define eigenspectrum bounds.\nbounds = (-2.5t, 2.5t)\n\n# Define order of Chebyshev expansion used in KPM approximation.\nM = 100\n\n# Update KPM approximation.\nupdate_kpmexpansion!(kpm_expansion, x -> fermi(x, μ, β), bounds, M)\n\n# Calculate KPM density matrix approximation.\nkpm_eval!(ρ_kpm, H, kpm_expansion, T1, T2, T3)\n\n# Check how good an approximation it is.\nprintln(\"Matrix Error = \", norm(ρ_kpm - ρ)/norm(ρ) )\n\n# Calculate approximate product with density matrix.\nkpm_mul!(ρv_kpm, H, kpm_expansion, v, α1, α2, α3)\n\n# Check how good the approximation is.\nprintln(\"Vector Error = \", norm(ρv_kpm - ρv) / norm(ρv) )","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = SmoQyKPMCore","category":"page"},{"location":"#SmoQyKPMCore","page":"Home","title":"SmoQyKPMCore","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for SmoQyKPMCore package. The SmoQyKPMCore package implements and exports an optimized, low-level implementation of the Kernel Polynomial Method (KPM) algorithm for approximating functions of operators with strictly real, bounded eigenvalues via a Chebyshev polynomial expansion.","category":"page"}]
}
